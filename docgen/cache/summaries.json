{
  "/home/eliezer/devs/xcore/xcore/appcfg.py:75993444ceef4c61c43434a9aff04bfaace81c9a621ff709ad5502bbb2d918c3": "## Technical Summary: XCore Configuration Module\n\n**Purpose:** This module centralizes the configuration and hook management for the XCore system, providing a foundational layer for application setup and extension points. \n\n**Key Components:**\n*   `Xcorecfg`: A class responsible for initializing the core XCore configuration using `Configure()`.\n*   `HookManager`:  A singleton instance managing all registered hooks within the XCore framework.\n\n**Dependencies:** This module relies on internal components from the `xcore` project, specifically `core` and `configurations`, as well as the `HookManager` defined in the `xcore.hooks` module. It does not directly import external libraries.\n\n**Interactions:** The `Xcorecfg` class is instantiated at application startup.  The `HookManager` serves as a central point for registering and invoking hooks throughout the XCore system. This module is called by other parts of the XCore codebase to access configuration settings and manage hook execution, facilitating modularity and extensibility.",
  "/home/eliezer/devs/xcore/xcore/manager.py:e21d55071aa1f0888c07c52866fcfad9da274a2deba0a4bea12f24ba0ad6eb42": "## Technical Summary: xcore.manager\n\n**Purpose:** The `manager.py` file serves as the central orchestrator within the xcore system, responsible for managing and loading plugins dynamically. It provides a single point of control for plugin initialization, execution, and monitoring.\n\n**Key Components:**\n\n*   `Manager`: The primary class that initializes the plugin management system, handles service injection, and manages the startup/shutdown lifecycle.\n*   `PluginManager`:  A core component responsible for loading, unloading, and managing plugins based on configuration. It utilizes a snapshot mechanism to detect changes and trigger reloads.\n*   `Snapshot`: Used for comparing plugin configurations across different states, triggering updates when necessary.\n*   `SupervisorConfig`: Defines parameters for the sandbox environment used by the plugins (timeout, restarts).\n\n**Dependencies:**\n\n*   `asyncio`: For asynchronous operations like plugin loading and monitoring.\n*   `os`:  For file system interactions (directory creation, path manipulation).\n*   `pkgutil`: Used to enumerate available modules within the `plugins_dir`.\n*   `xcore.sandbox.manager`: Provides the base `PluginManager` class.\n*   `xcore.sandbox.snapshot`: Offers snapshot functionality for change detection.\n*   `xcore.sandbox.supervisor`:  Provides configuration options for the plugin sandbox environment.\n\n**Interactions:**\n\nThe `Manager` initiates the system by calling `plugin_manager.load_all()` to load plugins from the specified directory (`plugins_dir`). It then attaches a unique FastAPI router, and maintains a reference to the `PluginManager` within the application's state. The `update_services()` function is used to inject services into the plugin manager before startup.  The `start_watching()` method performs periodic checks for configuration changes, triggering a reload of plugins if necessary. The `call()` method provides an interface for directly invoking plugin actions.",
  "/home/eliezer/devs/xcore/xcore/configurations/base.py:407ddc038d5149c7fc865a0ffe7756f8b55420c014aad35990d1a72966f8b543": "## Technical Summary \u2013 Configuration Management\n\n**Purpose:** This file provides a foundational module for loading and managing configuration data from a JSON file. It facilitates accessing and updating configuration settings within the system.\n\n**Key Components:**\n*   `Configure`: Loads the primary configuration from a specified JSON file, returning it as a dictionary.\n*   `BaseCfg`:  A base class for handling specific configuration sections, providing methods for retrieving, adding, removing, and saving data.\n\n**Dependencies:** This module utilizes `json` for parsing and writing JSON files and `rich` for formatted printing of configurations. It relies on the `Configure` class instance to load initial settings.\n\n**Interactions:** The `Configure` class is instantiated once per configuration file.  The `BaseCfg` class is instantiated with a `Configure` object and a section name. Methods like `getter`, `adder`, `remover`, and `saver` within `BaseCfg` allow modification of the configuration data, which is then written back to the JSON file. The `BaseCfg` class calls the `Configure` class's `__call__` method when requested.",
  "/home/eliezer/devs/xcore/xcore/configurations/core.py:560428f78ca82df45c4353893674a97f0cb72e2ff22b9becfc669b3fb91aa9c9": "## Technical Summary: Xcore Configuration Module\n\n**Purpose:** This module defines the core configuration settings for the xCore application, managing logging, data connections, extensions, and middleware. It provides a centralized point for configuring xCore\u2019s behavior.\n\n**Key Components:**\n*   `Datatypes`: Defines expected data types for configuration parameters (e.g., URL, echo flag).\n*   `RedisConfig`: Represents the Redis connection settings.\n*   `Xcore`:  A nested `TypedDict` holding default configurations including logging, extensions, requirements and middleware definitions.\n*   `Xcorecfg`: The primary class inheriting from `BaseCfg`, responsible for initializing and managing xCore configuration data. It includes a `cfgAcessMidlware` function to expose the middleware settings.\n\n**Dependencies:** This module imports `TypedDict` from the typing library, and utilizes classes defined in the `base` and `deps` modules (specifically `BaseCfg` and `Logger`).\n\n**Interactions:** The `Xcorecfg` class is instantiated with a `Configure` object passed during initialization. It provides access to middleware configurations via the `cfgAcessMidlware()` function.  It inherits configuration data from the `default_migration` dictionary, which can be overridden by a provided `Configure` instance. This module\u2019s settings are consumed by other parts of the application for runtime behavior.",
  "/home/eliezer/devs/xcore/xcore/configurations/deps.py:60ba26efc06024c7847a513174839495d4a484f68d439a6015be9fce0a1a5e80": "## Technical Summary \u2013 Dependency Configuration Module\n\n**Purpose:** This module defines a standardized configuration structure for logging, providing a centralized point to manage logging behavior across the XCore system. It establishes a consistent interface for enabling or disabling console and file-based logging.\n\n**Key Components:**\n\n*   `Logger`: A TypedDict defining the properties of a logger instance \u2013 `console` (boolean indicating console output enabled/disabled) and `file` (string representing the log file path).\n\n**Dependencies:** This module relies solely on the `typing` library for type hinting, specifically the `TypedDict` class. It does not import any internal XCore modules.\n\n**Interactions:**  This module is designed to be consumed by other components requiring logging functionality. It provides a configuration object that can be instantiated and its properties used to control logging behavior within those consuming modules. The module itself doesn't directly call or are called by other parts of the system; it serves as a configuration source.",
  "/home/eliezer/devs/xcore/xcore/configurations/manager.py:01a8d8afd0b9d4000055589bf59024c2df30ba236a81c2cac1139c35a382333c": "**Technical Summary**\n\n**Purpose:** This file defines the configuration structure for a management component, primarily responsible for setting up and monitoring various system processes within the xCore project. It centralizes settings related to plugins, tasks, logging, and snapshots.\n\n**Key Components:**\n*   `ManagerType`: A TypedDict representing the core configuration data, encompassing plugin directories, task schedules, logging preferences, and snapshot rules.\n*   `ManagerCfg`:  A class inheriting from `BaseCfg`, initializing a default `ManagerType` configuration with predefined settings for plugins, tasks, logging, and snapshots.\n\n**Dependencies:** This file imports `TypedDict` for data structure definition and `Logger` from the `.deps` module for logging functionality. It also relies on the `BaseCfg` class for fundamental configuration management.\n\n**Interactions:** The `ManagerCfg` class is instantiated with a `Configure` object, inheriting its properties.  It provides a default configuration (`default_migration`) if no custom configuration is provided. This component likely serves as an entry point for configuring other modules within the xCore system, particularly those related to background tasks and monitoring.",
  "/home/eliezer/devs/xcore/xcore/configurations/middleware.py:911064645930744a3b982f48a5b6ec53288f26f0306165c7d01bee94e4e70714": "## Technical Summary - Middleware Configuration Module\n\n**Purpose:** This module defines the configuration structure for middleware settings within the XCore system. It centralizes the definition of allowed origins for API requests, providing a standardized approach to security and routing. \n\n**Key Components:**\n*   `MidlwareTypes`: A TypedDict that specifies the expected format for middleware configurations, particularly the `origins` list.\n*   `BaseCfg`, `Configure`: These classes from the `base` module likely provide foundational configuration management functionality and a common interface for all configuration settings.\n\n**Dependencies:** This file relies on the `base` module, specifically `BaseCfg` and `Configure`. It utilizes Python's `typing` library for type hinting. \n\n**Interactions:**  This module is designed to be used by other configuration files within the XCore system. It likely receives origin lists from user-defined configurations and passes them to the API routing layer for enforcement. The `Configure` class probably handles the overall application configuration loading process.",
  "/home/eliezer/devs/xcore/xcore/configurations/migrations.py:a0809102786167502a5dda7397bcb13f15899bd0513b1238ac1a207603fc9a2b": "**Technical Summary**\n\nThis file defines the configuration structure for database migrations within the xCore system. Its primary purpose is to manage and orchestrate Alembic migration processes, including model discovery, backups, and logging.\n\n**Key Components:**\n*   `MigrationTypes`: A TypedDict representing the core migration settings, encompassing URL, auto-discovery, Alembic configuration, exclusion patterns, backup details, and logging options.\n*   `Migration`:  A class inheriting from `BaseCfg`, initializing with a `Configure` object and providing a default `MigrationTypes` dictionary.\n\n**Dependencies:**\n*   Imports `TypedDict` for structured data definition.\n*   Relies on modules `BaseCfg` and `Configure` for foundational configuration management, as well as `Logger` for logging functionality.\n\n**Interactions:**\nThe `Migration` class is instantiated with a `Configure` object, allowing customization of migration settings. It utilizes the `default_migration` dictionary as a fallback. The `responseModel()` function converts the `MigrationTypes` data into a standard response format. This file calls into the `Logger` module for logging and consumes configuration data from the `Configure` module.",
  "/home/eliezer/devs/xcore/xcore/configurations/plugins.py:27e743d1c36a19bbd3c7f622e1885902bc8c8cfd9c3c526c6aac587e9b12ba7a": "## Technical Summary \u2013 Plugins Configuration Module\n\n**Purpose:** This module defines the configuration structure for plugins within the XCore system. It centralizes plugin definitions and allows for both default and custom configurations to be managed.\n\n**Key Components:**\n*   `PluginsPEs`: A TypedDict defining the schema for plugin entry points, specifying `name` and `path`.\n*   `PluginsConfig`:  A configuration class inheriting from `BaseCfg`, responsible for managing plugin-related settings. It handles both default configurations and custom plugin definitions retrieved via a `Configure` object.\n\n**Dependencies:** This module imports `TypedDict` from the standard library and relies on internal modules `BaseCfg` and `Configure`, as well as the `Logger` module from `.deps`.\n\n**Interactions:** The `PluginsConfig` class is instantiated using a `Configure` object, receiving plugin definitions via the `conf.plugins` attribute. It utilizes the `BaseCfg`\u2019s functionality for configuration management.  It calls the parent class's `__getattribute__` method to handle attribute access.",
  "/home/eliezer/devs/xcore/xcore/configurations/redis.py:ddf21eb8b1b0936ea16abcb866fba0b5714f708ff0a17c21e3a930b0d33bb078": "## Technical Summary \u2013 Redis Configuration Module\n\n**Purpose:** This module defines the configuration structure for interacting with a Redis database within the xCore system. It provides a standardized way to specify connection parameters and default settings.\n\n**Key Components:**\n*   `Redis`: A TypedDict representing the core Redis configuration data (host, port, database number, TTL).\n*   `Rediscfg`:  A base class inheriting from `BaseCfg`, responsible for managing Redis-specific configurations. It initializes with a default Redis setup and merges it with any provided custom configuration.\n\n**Dependencies:** This module relies on the `BaseCfg` and `Configure` classes defined in the `.base` module, providing foundational configuration management functionality. \n\n**Interactions:**  The `Rediscfg` class is instantiated from a `Configure` object or uses a default Redis configuration if none is provided. It inherits the standard configuration retrieval mechanism via `__getattribute__`. The module likely provides configuration data to other parts of xCore that require Redis connectivity, and consumes configurations from the broader system.",
  "/home/eliezer/devs/xcore/xcore/configurations/secure.py:a06dc14cb9be9a08883adf7f32b1be0910a36693077c910148f10620ba7508e6": "## Technical Summary \u2013 Secure Configuration Module\n\n**Purpose:** This module defines the secure configuration settings for the system, specifically managing password hashing and dotenv file paths. It provides a standardized approach to configuring security-related parameters.\n\n**Key Components:**\n*   `PasswordType`: A TypedDict representing the structure of password hashing configurations (algorithms, scheme, category).\n*   `SecureTypes`: A TypedDict combining password type settings with a dotenv file path string.\n*   `Secure`:  A class inheriting from `BaseCfg`, responsible for initializing and managing secure configuration data, including default migration settings and custom overrides.\n\n**Dependencies:** This module imports `TypedDict` from the `typing` library and relies on the `BaseCfg` and `Configure` classes defined in the `.base` module.\n\n**Interactions:** The `Secure` class inherits configuration data from a `Configure` object, utilizing a default migration dictionary if no custom configuration is provided. It\u2019s designed to be called during system initialization to establish secure settings.  It consumes configuration data from the `Configure` module and produces a `SecureTypes` dictionary containing security-related parameters.",
  "/home/eliezer/devs/xcore/xcore/hooks/hooks.py:34c5db23e7098f9de84870a656aad58bdd3b8a03dc821e4f42af10005d83ad72": "## Technical Summary - xcore Hooks System\n\n**Purpose:** The `hooks.py` file implements a production-ready event system for the xcore project. It facilitates asynchronous and synchronous hook execution with prioritized ordering, wildcard pattern matching, one-time hooks, pre/post middleware (interceptors), timeout management, performance monitoring, and result processing pipelines. This allows developers to extend core functionality without directly modifying the main codebase.\n\n**Key Components:**\n\n*   `HookError`: Base exception for all hook-related errors.\n*   `HookTimeoutError`: Exception raised when a hook exceeds its configured timeout.\n*   `HookCancelledError`: Exception raised when a hook is cancelled (e.g., by an interceptor).\n*   `Event`: Represents structured event data, including name, data payload, metadata, cancellation status, and propagation stop flag.\n*   `HookResult`: Stores the outcome of a single hook execution, capturing details like function name, event name, result, error, execution time, and cancellation state.\n*   `HookInfo`:  Stores metadata about registered hooks (function, priority, once flag, timeout).\n*   `InterceptorResult`: An enum representing the possible results from an interceptor \u2013 `continue`, `skip`, or `cancel`.\n*   `HookManager`: The central class managing all registered hooks.\n\n**Dependencies:**\n\nThe file imports: `asyncio`, `fnmatch`, `inspect`, `logging`, `time`, `dataclasses`, and `enum`. It utilizes standard Python data structures like dictionaries, lists, and NamedTuples for efficient management of hook information and execution results.\n\n**Interactions:**\n\nThe `HookManager` is the core component.  It registers hooks using the `register()`, `on()` (decorator), and `once()` methods based on event names or wildcard patterns. Hooks are executed with priority, and the system supports interceptors for pre/post-execution logic. The `emit()` method (not shown in this chunk) is assumed to be used to trigger hook execution by sending events.  The manager tracks metrics related to hook performance and provides mechanisms for result filtering and processing.",
  "/home/eliezer/devs/xcore/xcore/hooks/hooks.py:afe5cf44d9b6b072f4bcc59bacee0ce8e2afe6834b7a46d0d4dadc83e1a90345": "## Technical Summary - Hooks Module\n\n**Purpose:** The `hooks` module facilitates event handling within the xCore system by providing a mechanism for intercepting and executing hooks based on defined patterns. It manages pre-execution and post-execution interceptors, as well as result processors, allowing for flexible modification and processing of events before and after hook execution.\n\n**Key Components:**\n\n*   `_pre_interceptors`: A dictionary mapping event names to lists of pre-execution interceptor functions (Callable).\n*   `_post_interceptors`: Similar to `_pre_interceptors`, but for post-execution interceptors.\n*   `_result_processors`: A dictionary mapping event names to lists of result processors (Callable) that transform hook results.\n*   `_get_matching_hooks(event_name)`:  A function that retrieves hooks matching a given event name, sorted by priority.\n*   `_get_matching_interceptors(event_name, interceptors_dict)`: A function that retrieves interceptors matching an event name, sorted by priority.\n*   `_run_pre_interceptors(event)`: An asynchronous function that executes pre-execution interceptors sequentially.\n*   `_run_post_interceptors(event, results)`: An asynchronous function that executes post-execution interceptors sequentially.\n*   `emit(event_name, data=None, **kwargs)`: The primary entry point for triggering hook execution; it dispatches the event to all matching hooks and interceptors.\n\n**Dependencies:**\n\n*   `fnmatch`: For wildcard pattern matching of event names.\n*   `inspect`:  For introspection (checking if functions are coroutines).\n*   `asyncio`: For asynchronous operations, including `asyncio.wait_for` for timeout handling.\n*   `logger`: For logging events and errors.\n\n**Interactions:**\n\nThe `emit` function is the primary entry point. It calls `_get_matching_hooks` to identify relevant hooks based on the event name.  It then iterates through these hooks, executing them using `_execute_single_hook`. The `_run_pre_interceptors` and `_run_post_interceptors` functions handle the sequential execution of interceptor functions, managing timeouts and error handling. Data is passed to hooks via the `event` object, and results are returned through the `HookResult` class.  The module relies on asynchronous operations for efficient event processing.",
  "/home/eliezer/devs/xcore/xcore/hooks/hooks.py:0ff4df554ccdd0d470b53bac40017ccd18973fa5b031bc3ddbc5c1979da36168": "## Technical Summary: Hooks Module\n\nThis file, `hooks.py`, implements a hook management system within the XCore framework. Its primary purpose is to facilitate event processing by allowing external code (hooks) to intercept and modify events before they are processed further. This module provides mechanisms for registering, executing, and managing these hooks based on event names.\n\n**Key Components:**\n\n*   `HookManager`: The central class responsible for managing all registered hooks. It handles event emission, hook execution, metric collection, and hook registration/deregistration.\n*   `Event`: Represents an event with a name and associated data.\n*   `HookResult`:  A data structure returned by executed hooks, containing information about the result (success/failure), any processed data, and execution time.\n*   `_run_pre_interceptors`, `_run_post_interceptors`: Asynchronous functions to execute pre- and post-event interceptor hooks.\n*   `_execute_single_hook`: Executes a single hook based on the event data and pattern matching.\n*   `_update_metrics`:  Collects performance metrics (emission count, execution time) for each event.\n*   `list_hooks`: Retrieves a list of registered hooks associated with specific event names or all events.\n\n**Dependencies:**\n\nThis module relies heavily on:\n\n*   `asyncio`: For asynchronous operations (event emission and hook execution).\n*   `logger`:  For logging errors and debug information.\n*   `fnmatch`: For pattern matching event names against registered hooks.\n*   `typing`: For type hinting (Dict, List, Optional, Callable).\n\n**Interactions:**\n\nThe `HookManager` is called by other components within XCore to emit events and trigger hook execution. It receives event data via the `data` parameter and uses it to match hooks based on their defined patterns.  It then executes these matching hooks, collecting results and updating performance metrics. The module also provides methods for clearing all registered hooks or hooks associated with a specific event.  The `emit_until_first` and `emit_until_success` functions are used to retrieve the first successful result from emitted events.\n",
  "/home/eliezer/devs/xcore/xcore/hooks/utils.py:f6bd9d497e0176814cba96adc66921777edec480903b6a963df9f9e897e8ebf3": "## Technical Summary of /home/eliezer/devs/xcore/xcore/hooks/utils.py\n\n**Purpose:** This file provides utility functions and decorators for the `xcore` hook system, enabling developers to intercept and modify events within the application's workflow. It offers pre-built interceptors for logging, rate limiting, debouncing, validation, and result processing.\n\n**Key Components:**\n\n*   `logging_interceptor`: An asynchronous decorator that logs event emissions with configurable log levels.\n*   `rate_limit_interceptor`: An asynchronous decorator that limits the frequency of events based on a defined window and maximum calls.\n*   `debounce_interceptor`: An asynchronous decorator that delays event processing until a specified delay has passed, effectively \"debouncing\" the event.\n*   `validation_interceptor`: An asynchronous decorator that validates event data against a list of required keys, preventing invalid events from proceeding.\n*   `error_counting_processor`: A processor function that aggregates and logs error counts for specific hooks and events, triggering warnings when thresholds are exceeded.\n*   `result_filter_processor`: A processor function to filter hook results based on success or failure status.\n*   `timing_processor`: A processor function that monitors the execution time of hooks and logs warnings if they exceed a defined threshold.\n*   `HookChain`: A class for creating sequential chains of hooks, allowing dependencies between them.\n*   `ConditionalHook`: A decorator to conditionally execute hooks based on event data conditions.\n*   `retry_hook`: A decorator that adds retry logic to hook functions in case of failures.\n\n**Dependencies:**\n\nThis file imports the following modules: `asyncio`, `inspect`, `time`, `functools`, and `typing`. It also relies on the internal `hooks` module, specifically the `Event`, `HookManager`, and `InterceptorResult` classes.  It uses the standard `logging` library for logging functionality.\n\n**Interactions:**\n\nThe `utils.py` file is primarily used as a decorator factory to create interceptors that are then registered with the `HookManager`. These interceptors are applied *before* events are processed by subsequent hooks in a chain. The `error_counting_processor` and `timing_processor` consume lists of `HookResult` objects, providing feedback on hook execution.  The `ConditionalHook` decorator dynamically adds or removes hooks based on event data conditions. The `HookChain` class facilitates the creation of dependent hook sequences.",
  "/home/eliezer/devs/xcore/xcore/hooks/utils.py:6919862b2018d4c88aaa8ffeeef3da9350a545c3f025545951906d906617931c": "## Technical Summary: Hook Utility Functions\n\n**Purpose:** This file provides utility functions for managing and caching asynchronous hook execution within the xCore system. It facilitates retry logic with exponential backoff and implements a memoization decorator to improve performance by caching results.\n\n**Key Components:**\n*   `memoized_hook`: A decorator that caches function calls based on event data, utilizing a time-to-live (TTL).\n*   `retry_decorator`:  A decorator implementing retry logic with exponential backoff for asynchronous functions.\n*   `wraps`: Decorator to preserve metadata of the wrapped function.\n\n**Dependencies:**\n*   `asyncio`: Provides asynchronous programming capabilities, including `asyncio.sleep`.\n*   `time`: Used for time-related operations (e.g., calculating expiry times).\n*   `typing`: For type hinting (Callable, Event, frozenset).\n\n**Interactions:** This file is primarily used as a decorator factory. The `memoized_hook` decorator is applied to asynchronous hook functions, caching their results based on event data and TTL. It calls the decorated function using `await` if it's an async function or directly if synchronous.  It interacts with the core hooks module through its decorated functions.",
  "/home/eliezer/devs/xcore/xcore/sandbox/manager.py:5544a3eeb85057b5d7addb49ca9995c25318f5b0b81a2f13bfa2ef044163a6eb": "## Technical Summary - `plugin_manager.py`\n\n**Purpose:** This file serves as the central orchestrator for managing and loading plugins within the xCore system. It provides a single entry point to the FastAPI core application, facilitating plugin discovery, activation, and route registration.\n\n**Key Components:**\n\n*   **`PluginManager` Class:** The core class responsible for managing the entire plugin lifecycle. Handles manifest loading, dependency resolution (using Kahn's algorithm), concurrent activation, and route attachment to a FastAPI application.\n*   **`ASTScanner` Class:**  A component used for Abstract Syntax Tree scanning within plugins, likely for security or validation purposes.\n*   **`RateLimiterRegistry` Class:** A registry managing rate limiting functionality, potentially preventing abuse of plugin endpoints.\n*   **`TrustedRunner` Class:** Handles the trusted execution environment for plugins, including signing and loading.\n*   **`SignatureError`, `PluginNotFound`, `ManifestError` Exceptions:** Custom exceptions to handle errors related to plugin management.\n\n**Dependencies:**\n\n*   **FastAPI:** (Imported via `TYPE_CHECKING`) Used as the underlying web framework for attaching routes.\n*   **logging:** For logging events and errors during plugin loading.\n*   **pathlib:**  For handling file paths.\n*   **typing:** For type hints.\n*   **contracts.base_plugin, contracts.plugin_manifest:** Internal modules defining the contract for plugins (manifest structure, execution modes).\n*   **sandbox.rate_limiter, sandbox.scanner, sandbox.supervisor:** Internal modules providing supporting services like rate limiting and AST scanning.\n\n**Interactions:**\n\n*   **Called By:** The main xCore application uses `PluginManager` to load and activate plugins.\n*   **Calls Into:**  The `PluginManager` calls functions within the internal modules (e.g., `ASTScanner`, `RateLimiterRegistry`) for scanning, rate limiting, and other tasks. It also interacts with external `TrustedRunner` for secure plugin execution.\n*   **Data Produced/Consumed:** The `PluginManager` consumes plugin manifests to determine dependencies and activation order.  It produces activated plugins (with attached routes) that can be accessed via the FastAPI application.\n\nThis file implements a robust plugin management system, utilizing dependency resolution and concurrent activation to ensure efficient plugin loading within the xCore architecture. It leverages internal modules for scanning, rate limiting, and trusted execution, providing a secure and well-structured approach to plugin integration.",
  "/home/eliezer/devs/xcore/xcore/sandbox/manager.py:7612e651ce6a12f45f4023385a2bf02150eebdbc3e30ceaa9bb7139382619908": "## Technical Summary - xCore Plugin Manager\n\n**Purpose:** This file manages the activation and execution of plugins within the xCore system. It provides a centralized point for loading, running, and monitoring plugins, handling dependencies, and managing execution modes (Trusted, Sandboxed, Legacy).\n\n**Key Components:**\n\n*   `Manager`: The primary class responsible for orchestrating plugin loading and execution.\n    *   `_try_activate(plugin)`: Asynchronously attempts to activate a single plugin manifest, handling compatibility checks and logging results.\n    *   `_activate(manifest)`:  Activates a plugin based on its configuration, setting up rate limiting, and routing it to the appropriate execution environment (Trusted or Sandboxed).\n    *   `_activate_trusted(manifest)`: Activates a Trusted plugin, performing signature verification and running a static AST scan.\n    *   `_activate_sandboxed(manifest)`: Activates a Sandboxed plugin, starting a Sandbox supervisor process.\n    *   `call(plugin_name, action, payload)`: The public entry point for invoking plugins, incorporating rate limiting, retry logic, and routing based on the plugin's execution mode.\n\n**Dependencies:**\n\n*   `asyncio`: Asynchronous I/O library for concurrent operations.\n*   `PluginManifest`:  A data structure representing a plugin\u2019s configuration (version, dependencies, resources).\n*   `TrustedRunner`, `SandboxSupervisor`: Classes responsible for executing plugins in their respective environments.\n*   `_scanner`: An AST scanner used to perform static analysis of plugins.\n*   `_rate`: A rate limiting component.\n\n**Interactions:**\n\nThe `Manager` interacts with the codebase primarily through its `call()` method, which is called by external systems to execute plugin actions. It calls into the `_try_activate`, `_activate_trusted`, and `_activate_sandboxed` methods for specific activation scenarios.  It consumes data from `PluginManifest` objects (version, resources) and produces dictionaries representing the results of plugin executions. The manager also interacts with logging services via the `logger` object. It relies on external libraries like `asyncio` and potentially others depending on the implementation details not present in this chunk.",
  "/home/eliezer/devs/xcore/xcore/sandbox/manager.py:b970b9fb84ebfd43f114dca0476245bce942e7fec098ee000e4234cb88e7f2c5": "## Technical Summary - PluginManager\n\n**Purpose:** The `manager.py` file provides a central mechanism for loading, unloading, and managing plugins within the XCore system. It facilitates dynamic plugin activation and deactivation, supporting a sandboxed environment for potentially untrusted code while maintaining a trusted zone for known, verified plugins.\n\n**Key Components:**\n*   `load(self, plugin_name: str) -> None`: Asynchronously loads a plugin based on its directory name, utilizing `load_manifest` to parse the manifest and then activating it.\n*   `unload(self, plugin_name: str) -> None`: Asynchronously unloads a plugin by stopping its associated process and removing it from internal data structures.\n*   `reload(self, plugin_name: str) -> None`: Reloads an existing plugin, re-registering resources and reattaching routes after a hot-reload.\n*   `shutdown(self, timeout: float = 10.0) -> None`: Gracefully shuts down all loaded plugins with a configurable timeout to prevent deadlocks.\n*   `status(self) -> dict`: Returns a dictionary containing the status of all trusted and sandboxed plugins.\n\n**Dependencies:**\n*   `asyncio`: Utilized for asynchronous operations, particularly in `load`, `unload`, `reload`, and `shutdown`.\n*   `os`: Used for path manipulation (`plugin_dir`).\n*   `load_manifest(plugin_dir)`: An external function (not defined here) responsible for parsing the manifest file of a plugin.\n*   `self._trusted`, `self._sandboxed`: Internal dictionaries holding references to loaded plugins, categorized by trust level.\n\n**Interactions:**\nThe `manager` interacts with the rest of the codebase primarily through its asynchronous methods. It calls into the `_activate`, `_stop`, and `reload` methods of individual plugin instances (presumably defined elsewhere). The `status()` method provides a summary of plugin states to other components, likely for monitoring or diagnostic purposes.  The `shutdown` function orchestrates the cleanup process across all loaded plugins.",
  "/home/eliezer/devs/xcore/xcore/sandbox/router.py:79af1800cc248228c847a1098b983716d614b9b8ad56382e80a362a654a2ffd7": "This file implements a FastAPI router for managing plugin calls within the xcore system. Its primary purpose is to provide a centralized point of entry for interacting with plugins, abstracting away differences between trusted (in-process) and sandboxed (subprocess IPC) plugin implementations.\n\n**Key Components:**\n\n*   `PluginCallRequest`: A Pydantic model defining the payload structure for plugin calls.\n*   `PluginCallResponse`: A Pydantic model representing the response from a plugin call, including status, plugin name, action, and result.\n*   `APIKeyHeader`: FastAPI dependency to authenticate API requests using an API key header.\n*   `verify_admin_key`: An asynchronous function that validates the API key header for administrative routes.\n*   `get_plugin_manager`: An asynchronous function retrieving the `PluginManager` instance from the request app state, handling potential initialization errors.\n*   `router`: The FastAPI APIRouter defining the plugin endpoint structure.\n\n**Dependencies:**\n\nThis file imports:\n\n*   `FastAPI` for routing and API functionality.\n*   `APIRouter` to define the API endpoints.\n*   `Depends` for dependency injection.\n*   `HTTPException` for handling HTTP errors.\n*   `Request` for accessing request context information.\n*   `Security` for API key authentication.\n*   `BaseModel` from `pydantic` for data validation and serialization.\n*   `PluginManager` (from .manager) \u2013 the core component responsible for managing plugin lifecycle events (loading, unloading, calling).\n\n**Interactions:**\n\nThe router is called by client applications to initiate plugin calls via `/app/{plugin_name}/{action}` endpoints. It relies on the `PluginManager` to execute the requested action on the specified plugin. The router also handles administrative operations like reloading and unloading plugins through protected routes requiring API key authentication.  It consumes the `PluginCallRequest` payload and produces a `PluginCallResponse`.",
  "/home/eliezer/devs/xcore/xcore/sandbox/contracts/base_plugin.py:37ee5179b958829836d0d554408f607755785365b2a7643ba86d5fd10404a668": "## Technical Summary of BasePlugin Contract\n\nThis file defines a foundational contract for all plugins within the XCore system, promoting loose coupling and enabling both Trusted and Sandboxed plugin types. \n\n**Purpose:** The `BasePlugin` contract establishes a standardized interface for interacting with the core system, ensuring consistent behavior across different plugins.\n\n**Key Components:**\n*   `BasePlugin`: An abstract protocol defining the core `handle()` method \u2013 the single entry point for all plugins to process actions and payloads.\n*   `TrustedBase`: An abstract base class providing an optional mechanism for Trusted plugins to inject dependencies from the core system via a service dictionary. It includes methods like `get_service()` for accessing injected services and lifecycle hooks (`on_load`, `on_unload`, `on_reload`).\n*   `ok()` & `error()`: Utility functions for constructing standardized success and error response dictionaries.\n\n**Dependencies:** This file utilizes the `abc` module (abstract base classes) and `typing` module (Protocol, runtime_checkable, Any). It does not directly import any core XCore modules.\n\n**Interactions:**  Plugins implementing `BasePlugin` must implement the `handle()` method. `TrustedBase` plugins leverage injected services through their `get_service()` method. The `ok()` and `error()` functions are used by plugins to return standardized responses to the system, facilitating consistent error handling.\n",
  "/home/eliezer/devs/xcore/xcore/sandbox/contracts/plugin_manifest.py:af3402caf1a1e5fbd7b015ac286a8bb86cfc6dcb00547cd69a9f5ad6a9096a31": "## Technical Summary: Plugin Manifest Parser\n\n**Purpose:** This file defines the structure and parsing logic for a `plugin.yaml` manifest file, used to configure plugin execution environments within the XCore system. It generates dataclasses representing various configuration options based on the specified execution mode (Trusted, Sandboxed, or Legacy).\n\n**Key Components:**\n\n*   **`ExecutionMode` Enum:** Defines the supported execution modes, impacting default configurations.\n*   **`PluginManifest` Dataclass:** Represents the complete plugin manifest, containing metadata like name, version, and configuration sections.\n*   **ResourceConfig Dataclass:**  Defines resource limits (timeout, memory, disk) and rate limiting settings for a plugin's execution.\n*   **RuntimeConfig Dataclass:** Configures runtime aspects such as logging level, health checks, and retry mechanisms.\n*   **FilesystemConfig Dataclass:** Specifies allowed and denied file system paths for the plugin.\n*   **RateLimitConfig Dataclass:** Defines call rate limits and their periods.\n*   **HealthCheckConfig Dataclass:** Configures health check settings (enabled status, interval, timeout).\n*   **RetryConfig Dataclass:**  Defines retry configurations (max attempts, backoff seconds).\n\n**Dependencies:**\n\n*   `json`: Used for parsing the YAML manifest file.\n*   `os`: Provides access to environment variables.\n*   `re`: Utilized for resolving environment variable references within the manifest.\n*   `pathlib`:  Provides Path objects for filesystem manipulation.\n*   `dataclasses`: For defining data classes with default values and methods.\n*   `enum`: For creating enumerations like `ExecutionMode` and `LogLevel`.\n\n**Interactions:**\n\nThe `PluginManifest` class is the central point of interaction. It's instantiated from a parsed YAML manifest. The file uses environment variable resolution (`_resolve_env`) to populate configuration values based on references within the manifest (e.g., `$ENV_VAR`).  It also provides methods like `is_trusted()` and `is_sandboxed()` for determining execution mode, and `effective_defaults()` which returns the appropriate default configurations based on the plugin's execution mode. The file is likely called during plugin initialization to set up its environment.",
  "/home/eliezer/devs/xcore/xcore/sandbox/contracts/plugin_manifest.py:481a8c58cd0a8d7479f7ec886539d6376db91e1c49fa3e91eef1570e44fb1cb3": "## Technical Summary of `plugin_manifest.py`\n\n**Purpose:** This file defines the structure and validation logic for a plugin manifest, a configuration file used to describe and initialize plugins within the XCore system. It handles loading, parsing, and validating these manifests to ensure consistency and compatibility with the core application.\n\n**Key Components:**\n\n*   `_load_raw(plugin_dir: Path) -> dict[str, Any]`:  Loads raw data from either a `plugin.yaml` or `plugin.json` file within a plugin directory. It handles YAML parsing using the `pyyaml` library and JSON parsing natively.\n*   `_inject_envfile(raw: dict, plugin_dir: Path)`: Loads environment variables from a `.env` file (if specified in the manifest) using the `dotenv` library.\n*   `load_manifest(plugin_dir: Path) -> PluginManifest`: The primary function that orchestrates the entire process. It loads the raw data, validates it against required fields and execution modes, resolves environment variables, and constructs a `PluginManifest` object.\n\n**Dependencies:**\n\n*   `yaml`: For parsing YAML configuration files (requires installation via `pip install pyyaml`).\n*   `json`:  For parsing JSON configuration files.\n*   `dotenv`: For loading environment variables from `.env` files.\n*   `re`: Regular expression library for version string parsing.\n\n**Interactions:**\n\nThis file is called by other parts of the XCore codebase to load and utilize plugin configurations. Specifically, it's invoked within `load_manifest` which then uses the resulting `PluginManifest` object to initialize plugins. The file calls into external libraries (`pyyaml`, `json`, `dotenv`) for parsing and loading configuration data. It produces a `PluginManifest` object that is consumed by other modules for plugin instantiation and execution.  The manifest itself defines the parameters used to configure the plugin's behavior, including entry points, allowed imports, and runtime settings.",
  "/home/eliezer/devs/xcore/xcore/sandbox/sandbox/disk_watcher.py:689b4280e66403dbed9f19ded0f2c92ff63d90b1611e50f48b599ad2b4c01107": "## Technical Summary: DiskQuotaExceeded Module\n\n**Purpose:** This module, `disk_watcher.py`, implements a disk space monitoring system for sandboxed plugins within the XCore project. Its primary function is to prevent plugin writes from exhausting available storage on the host machine, ensuring stability and preventing data loss. It operates as a preventative measure before writes occur and periodically checks existing usage.\n\n**Key Components:**\n\n*   `DiskWatcher`: The core class responsible for monitoring disk space. It tracks the size of the `data/` directory associated with each plugin.\n    *   `__init__(self, data_dir: Path, max_disk_mb: int)`: Initializes the watcher with the data directory path and maximum allowed disk usage in megabytes.\n    *   `current_size_bytes(self) -> int`: Calculates the total size of all files within the `data/` directory in bytes.\n    *   `check(self, plugin_name: str)`:  Checks if the current disk usage exceeds the configured limit for a given plugin. Raises `DiskQuotaExceeded` if exceeded.\n    *   `check_write(self, plugin_name: str, estimated_bytes: int = 0)`: Checks if writing additional data will exceed the quota before allowing the write operation.\n    *   `stats(self) -> dict`: Returns a dictionary containing statistics about disk usage (used space in MB, maximum allowed space in MB, percentage used, and a boolean indicating whether the quota is within limits).\n\n*   `DiskQuotaExceeded(Exception)`: A custom exception raised when a plugin exceeds its allocated disk space.\n\n**Dependencies:**\n\n*   `logging`: Provides logging functionality for debugging and monitoring.\n*   `pathlib.Path`:  Used for representing file paths in an object-oriented manner, simplifying path manipulation.\n\n**Interactions:**\n\nThe `DiskWatcher` is called primarily by the XCore system's plugin management component (not explicitly shown here) before any write operation to a plugin\u2019s data directory. It also checks the size of the data/ directory periodically.  It calls into the filesystem to determine file sizes. The module does not directly call other modules, but it is designed to be integrated with the broader XCore system for handling plugin operations and monitoring.",
  "/home/eliezer/devs/xcore/xcore/sandbox/sandbox/scanner.py:4ced2c0d2740e5ce2077a0d48089b4cc70e0f6907b3c90805cd0f4c60e1dfa6a": "## Technical Summary: xCore Sandbox Plugin Scanner\n\n**Purpose:** This file implements a static analysis tool, the \"Sandbox Scanner,\" designed to assess Python plugins within the xCore project for potential security vulnerabilities and compliance issues before deployment. It identifies disallowed module imports, dangerous code patterns, and other risky behaviors. The scanner's primary goal is to prevent malicious or poorly-written plugins from compromising the core system.\n\n**Key Components:**\n\n*   `ScanResult`: A dataclass that aggregates the results of the scan, tracking whether the scan passed, listing errors, warnings, and a log of scanned files.\n*   `ASTScanner`: The main class orchestrating the scanning process. It manages configuration (forbidden/allowed modules, dangerous patterns) and delegates to the `_ImportVisitor`.\n*   `_ImportVisitor`: An AST visitor that traverses the parsed Python code, checking for disallowed imports and dangerous code constructs using `ast.parse` and regular expressions.\n\n**Dependencies:**\n\n*   `ast`: The standard library's Abstract Syntax Tree module for parsing Python code.\n*   `re`:  The standard library\u2019s regular expression module for pattern matching.\n*   `pathlib`: For path manipulation, specifically to resolve plugin directories.\n*   `dataclasses`: For defining the `ScanResult` dataclass.\n\n**Interactions:**\n\nThe `ASTScanner` is called by other parts of the xCore system (e.g., deployment pipeline). It takes a plugin directory as input and performs static analysis on all `.py` files within the `src/` subdirectory. The scanner identifies violations, adding them to the `ScanResult`.  It also uses regular expressions to detect dangerous code patterns directly in the source code, regardless of AST parsing. The result is then returned for further processing or reporting. The scanner does *not* call any external services or interact with the system itself; it solely performs static analysis on the provided plugin code.",
  "/home/eliezer/devs/xcore/xcore/sandbox/sandbox/ipc.py:fe7c2a2a40f0856b08ca000bf546e5302405318affca3e93f084fe37682acbf9": "## Technical Summary: /home/eliezer/devs/xcore/xcore/sandbox/ipc.py\n\n**1. Purpose:**\n\nThis file, `ipc.py`, provides a communication channel between the main XCore application and a sandboxed subprocess. It facilitates asynchronous data exchange using JSON-formatted messages via stdin/stdout, enabling interactions with potentially unstable or resource-intensive operations within the sandbox environment.  The primary goal is to decouple core functionality from potentially problematic processes.\n\n**2. Key Components:**\n\n*   `IPCChannel`: The central class managing the communication channel. It handles sending requests to the subprocess and receiving responses, incorporating timeout mechanisms and error handling.\n*   `IPCResponse`: A dataclass representing the result of an IPC call, containing boolean success status, parsed data (as a dictionary), and the raw JSON response string for debugging.\n*   `IPCError`:  A base exception class for all communication-related errors within the IPC channel. Subclasses like `IPCTimeoutError` and `IPCProcessDead` inherit from this.\n\n**3. Dependencies:**\n\n*   `asyncio`: Provides asynchronous programming primitives, including locks, wait\\_for, and event loops necessary for non-blocking I/O operations.\n*   `json`: Used for encoding and decoding JSON messages between the main application and the subprocess.\n*   `logging`:  Used for logging errors and debugging information related to IPC communication.\n*   `dataclasses`: Provides a simple way to define classes that primarily hold data, used here for the `IPCResponse`.\n\n**4. Interactions:**\n\nThe `IPCChannel` establishes a connection with an existing `asyncio.subprocess.Process` instance.  It uses `call()` to send requests (JSON strings) to the subprocess via its standard input (`stdin`). The subprocess processes these requests and returns responses, which are received by the channel via standard output (`stdout`). The `call()` function includes a timeout mechanism to prevent indefinite blocking if the subprocess fails to respond. Error handling is implemented to catch potential issues like timeouts, dead processes, or invalid JSON responses.  The `close()` method ensures proper termination of the subprocess's stdin connection before exiting.",
  "/home/eliezer/devs/xcore/xcore/sandbox/sandbox/rate_limiter.py:5ec40ec7570d687de1cd2d2827060ec5398b2df6bb06f139ac9b4b419550b5ed": "## Technical Summary: Rate Limiting Module\n\n**Purpose:** This module implements a rate limiting system to control the frequency of requests to prevent abuse, overload, and ensure fair usage of resources within the XCore platform. It operates on a per-plugin basis, allowing granular control over request rates for individual services or components.\n\n**Key Components:**\n\n*   `RateLimiter`: The core class responsible for enforcing rate limits. It utilizes a sliding window algorithm (implemented with a deque) to track requests and enforce the configured limit. Key methods include `check()` for rate limiting and `stats()` for retrieving current statistics.\n*   `RateLimitExceeded`: An exception raised when a request exceeds the defined rate limit.\n*   `RateLimiterRegistry`: A registry that manages instances of `RateLimiter`, associating each with its corresponding plugin name. This allows efficient lookup and invocation of the rate limiter based on the calling plugin.\n\n**Dependencies:**\n\n*   `asyncio`: Provides asynchronous programming capabilities, including lock management for thread-safe operation.\n*   `collections.deque`: Used to efficiently implement the sliding window algorithm.\n*   `time`: Utilized for obtaining monotonic timestamps (immune to system clock adjustments).\n*   `RateLimitConfig`: A configuration object defining rate limit parameters like `period_seconds` and `calls`.\n\n**Interactions:**\n\nThe `RateLimiterRegistry` is called by other modules within the XCore codebase, typically during request processing.  Specifically, the `check()` method of the registry is invoked to enforce rate limits before a request can proceed. The `check()` method itself calls the `check()` method on the appropriate `RateLimiter` instance based on the plugin name. The RateLimiter then uses its internal sliding window algorithm to determine if the current request should be allowed or if it should raise a `RateLimitExceeded` exception.  The registry also provides a `stats()` method for retrieving rate limiting statistics, useful for monitoring and debugging. This module is designed to integrate seamlessly into the XCore architecture, providing a robust mechanism for managing request rates across various components.",
  "/home/eliezer/devs/xcore/xcore/sandbox/sandbox/snapshot.py:625e83ebc1e83ea93133f1765ef17eee8e8b29faa218fc9af377f211bc473cc5": "## Technical Summary: XCore Sandbox - Plugin Manager Snapshot Module\n\n**1. Purpose:**\n\nThis module, located at `/home/eliezer/devs/xcore/xcore/sandbox/xcore`, manages the snapshotting and comparison of plugin directories within the XCore system. Its primary role is to enable dynamic plugin reloading by detecting changes in installed plugins without requiring a full restart.\n\n**2. Key Components:**\n\n*   `Snapshot`: The core class responsible for creating, comparing, and updating snapshots of plugin directory contents. It utilizes hashing to identify changed files.\n*   `_get_cfg()`: A helper function that lazily initializes the XCore configuration manager (`ManagerCfg`), ensuring configurations are available without immediate import overhead.\n*   `_hash_file(path)`: Calculates a SHA256 hash of a file's contents, used for identifying changes.\n*   `_should_ignore(path)`: Determines if a given file or directory should be excluded from the snapshot based on configured ignore rules (hidden files, specific extensions, and filenames).\n\n**3. Dependencies:**\n\nThis module relies heavily on the core XCore configuration system (`ManagerCfg`) for settings like ignored file types. It also utilizes standard Python libraries such as `hashlib` for hashing and `os` for directory traversal.  It imports `logging` for error reporting and `pathlib` for path manipulation.\n\n**4. Interactions:**\n\nThe `Snapshot` class is called by the Plugin Manager to periodically check for changes in installed plugins. It creates a snapshot of the plugin directory, compares it with a previously stored snapshot, and reports any differences. The `__call__` method allows the Snapshot object to be used as a function, taking a directory path as input and returning a change report.  The module primarily consumes data from the plugin directories themselves via file hashing and ignores configuration settings defined in the XCore configuration manager.",
  "/home/eliezer/devs/xcore/xcore/sandbox/sandbox/supervisor.py:dda07f576545f195fd942be0f121d4d2412920a9b9a9b0de9628803d8ac1fcf2": "## Technical Summary of `sandbox/supervisor.py`\n\n**Purpose:** This file manages the lifecycle of a sandboxed plugin, providing core functionality like process execution, health checks, environment injection, and disk monitoring. It acts as a central orchestrator for the plugin's operation within the xCore system.\n\n**Key Components:**\n\n*   `SupervisorConfig`: A dataclass defining configuration parameters such as timeout values, restart limits, and startup timeouts.\n*   `SandboxSupervisor`: The primary class responsible for initiating, monitoring, and controlling the sandboxed plugin process. It contains methods for starting, stopping, calling functions within the plugin, and handling errors.\n*   `ProcessState`: An enum representing the different states of the plugin's subprocess (STOPPED, STARTING, RUNNING, RESTARTING, FAILED).\n*   `IPCChannel`: Handles inter-process communication with the sandboxed plugin using an asynchronous channel.\n*   `DiskWatcher`: Monitors disk usage for the plugin\u2019s data directory to prevent exceeding resource limits.\n\n**Dependencies:**\n\n*   `asyncio`: For asynchronous programming and subprocess management.\n*   `contextlib`: Provides context managers for error handling (e.g., suppressing exceptions).\n*   `logging`:  For logging events and errors.\n*   `pathlib`: For path manipulation.\n*   `dataclasses`: For defining data classes like `SupervisorConfig`.\n*   `enum`: For defining enumerations like `ProcessState`.\n*   `subprocess`: For creating and managing subprocesses.\n*   `disk_watcher`: (Internal Module) Provides disk quota monitoring functionality.\n*   `ipc`: (Internal Module) Handles inter-process communication.\n\n**Interactions:**\n\nThe `SandboxSupervisor` initiates the sandboxed plugin's process using `asyncio.subprocess.create_subprocess_exec`. It establishes an asynchronous IPC channel for communication. The supervisor calls functions within the plugin via the IPC channel, primarily through the `call()` method.  It monitors the plugin\u2019s health and disk usage using scheduled tasks. Upon subprocess termination (due to crash or exit), the supervisor handles restarting the process according to configured settings. Data is exchanged between the supervisor and the plugin via the IPC channel. The supervisor consumes data from the plugin via the `call` function, and produces status updates through the IPC channel.",
  "/home/eliezer/devs/xcore/xcore/sandbox/sandbox/supervisor.py:c0d428c9f1479e405a0152ba3eb02d0f95808c270d129a264cb44f30ec301003": "**Technical Summary: Supervisor Module**\n\nThis module manages the lifecycle of sandboxed processes within the system. Its primary purpose is to handle process restarts and provide a status report.\n\n**Key Components:**\n*   `_handle_crash()`: Detects crashes, increments restart count, and attempts a restart if configured.\n*   `stop()`: Gracefully shuts down the process by canceling tasks, closing channels, and terminating the underlying subprocess.\n*   `_kill()`: Terminates or forcefully kills the associated subprocess using `terminate()` and `kill()`.\n*   `status()`: Returns a dictionary containing detailed information about the process\u2019s state, resources, and limits.\n\n**Dependencies:**\nThis file relies on `asyncio`, `logging`, `ProcessState`, `Manifest`, `Resources`, and `DiskStats` modules. It utilizes an underlying subprocess managed by `self._process`.\n\n**Interactions:**\nThe `_handle_crash()` function is called recursively upon restart failures. The `stop()` method cancels associated tasks (watch and health) and closes communication channels.  It calls the `_kill()` function to terminate the process, and the `status()` function provides a snapshot of the process\u2019s current state for monitoring purposes.",
  "/home/eliezer/devs/xcore/xcore/sandbox/sandbox/worker.py:39ba36a3806a8969c8e84d6c3d85cebcd7307d1eb208d0c3491505e4162e475f": "## Technical Summary of `worker.py`\n\n**Purpose:** This file implements a worker process within a sandbox environment, designed to receive and process JSON-formatted requests from stdin. It avoids blocking the main event loop by utilizing an executor thread for I/O operations.\n\n**Key Components:**\n*   `_apply_memory_limit()`: Sets memory limits using `resource` module to constrain the sandbox process.\n*   `_read_line_blocking()`: Reads a line from stdin\u2019s buffer, executed within an executor.\n*   `_main()`: The asynchronous main function that orchestrates request handling and plugin execution.\n*   `_write()` & `_write_error()`: Functions for writing results (JSON formatted) to stdout.\n\n**Dependencies:**\n*   `asyncio`: Provides the event loop and asynchronous programming capabilities.\n*   `json`: For parsing and serializing JSON data.\n*   `logging`: For logging events and errors.\n*   `resource`: Used for setting memory limits.\n*   `sys`: Access to system-specific parameters like stdin.\n\n**Interactions:**\nThe `worker.py` script is invoked from the main program, receiving input via standard input (stdin). It calls into a dynamically loaded plugin module (`main`) to perform actions based on received requests. The output of the plugin\u2019s execution is serialized as JSON and written back to stdout.  It utilizes an executor thread to avoid blocking the event loop during I/O operations.",
  "/home/eliezer/devs/xcore/xcore/sandbox/trusted/runner.py:158d0cfe21b3accd8990cd556bf525536725395429fb441d04460d976dc06cfd": "## Technical Summary of `runner.py`\n\n**Purpose:** This file implements a mechanism for in-process loading and execution of \"Trusted\" plugins within the xCore system. It manages plugin initialization, handles execution with timeout protection, and enforces filesystem access controls based on configuration.\n\n**Key Components:**\n\n*   **`TrustedRunner` Class:** The core class responsible for managing the lifecycle of loaded Trusted plugins.\n    *   `__init__(self, manifest: PluginManifest, services: dict[str, Any] | None = None)`: Initializes the runner with a plugin manifest and optional service dependencies.\n    *   `load(self)`: Loads the specified plugin module from its location within the plugin directory, handles dependency resolution (including adding `src/` to the Python path), and instantiates the plugin class.\n    *   `call(self, action: str, payload: dict) -> dict`: Executes a function or method defined in the loaded plugin with a specified action and payload, incorporating a timeout mechanism.\n    *   `check_path(self, path: str | Path) -> None`:  Performs filesystem access checks based on the plugin manifest's configuration to ensure compliance with security policies.\n    *   `reload(self)`: Reloads the currently loaded plugin module.\n\n*   **`TrustedLoadError(Exception)`:** A custom exception raised when a problem occurs during plugin loading (e.g., missing entry point, invalid plugin class).\n*   **`FilesystemViolation(Exception)`:**  A custom exception raised when a Trusted plugin attempts to access a file or directory outside of the allowed paths defined in the manifest.\n\n**Dependencies:**\n\n*   `__future.annotations`: Enables type hints for improved code readability and static analysis.\n*   `asyncio`: Provides asynchronous programming capabilities for handling timeouts and concurrent execution.\n*   `importlib.util`: Used for dynamic module loading.\n*   `logging`: For logging plugin activity and errors.\n*   `pathlib`:  For path manipulation (resolving paths).\n*   `typing`: For type hinting.\n*   `BasePlugin`, `TrustedBase`, `PluginManifest`, `FilesystemConfig`: Interfaces defined in the `contracts` module, defining the expected behavior of Trusted plugins.\n\n**Interactions:**\n\nThe `TrustedRunner` is called by other parts of the system to execute actions performed by Trusted plugins. It receives action requests and payloads via the `call()` method.  It also utilizes the `check_path()` method to enforce filesystem access restrictions, which are provided as a service to the plugin itself. The runner imports modules dynamically using `importlib.util`, resolving dependencies within the plugin directory. The `load()` function is the primary entry point for initializing a Trusted plugin.\n",
  "/home/eliezer/devs/xcore/xcore/sandbox/trusted/runner.py:1dc0967ecc2db28b97b17b23684486984a5902572a1b604914af8adce67f0d6d": "**Technical Summary: Trusted Runner Module**\n\nThis module manages the execution of trusted plugins within the XCore system. Its primary purpose is to load, unload, and monitor these plugins, enforcing security constraints.\n\n**Key Components:**\n*   `unload()`: Removes the plugin from memory and updates system paths.\n*   `load()`: Loads the plugin module into the system.\n*   `status()`: Returns a dictionary detailing the plugin\u2019s state (name, mode, loaded status, uptime, resource limits).\n\n**Dependencies:**\n*   `sys`: Utilized for managing modules within the Python environment.\n*   `time`: Used to calculate and report uptime.\n*   `logger`: Provides logging functionality.\n\n**Interactions:**\nThe runner is called by other parts of the system when a trusted plugin needs to be executed. It calls `on_load()` and `on_unload()` methods within the plugin module during loading and unloading, respectively. The `status()` function provides real-time information about the plugin's operation.  It consumes data from the plugin manifest (name, resources, filesystem) and produces status updates for monitoring purposes.",
  "/home/eliezer/devs/xcore/xcore/sandbox/trusted/signer.py:fb9779c9b9f841048d78bbbbcdc0c34ebf376d09777edce693a3cc85efd239e0": "## Technical Summary: Trusted Signer Module\n\n**Purpose:** This module, `signer.py`, provides a mechanism for securely signing and verifying trusted plugins within the XCore system. It leverages HMAC-SHA256 to ensure plugin integrity and authenticity, preventing unauthorized modifications. The core function is to guarantee that a plugin hasn't been tampered with since its creation.\n\n**Key Components:**\n\n*   `_compute_plugin_hash(manifest, secret_key)`: Calculates the SHA256 hash of all files within a plugin\u2019s `src/` directory and the manifest file itself, ensuring a consistent representation for signature generation.\n*   `sign_plugin(manifest, secret_key)`: Generates the plugin's signature by hashing its contents and storing it in a `plugin.sig` file. This function is intended for use during deployment or administration, not runtime.\n*   `verify_plugin(manifest, secret_key)`: Verifies the plugin\u2019s signature by recalculating the hash and comparing it to the stored value. It includes version validation to prevent activation of outdated plugins.\n*   `is_signed(manifest)`: Checks if a plugin has a `plugin.sig` file present, indicating that signing was performed.\n\n**Dependencies:**\n\n*   `hashlib`: Provides SHA256 hashing functionality.\n*   `hmac`:  Provides HMAC-SHA256 for secure message authentication.\n*   `json`: Used to serialize and deserialize the signature data in the `plugin.sig` file.\n*   `logging`: For logging events related to signing and verification.\n*   `Pathlib`: Provides a way to interact with files and directories using objects.\n*   `PluginManifest`:  A contract defining the structure of plugin metadata (name, version, directory).\n\n**Interactions:**\n\nThe `signer.py` module is primarily called by the Plugin Manager during plugin activation. It receives a `PluginManifest` object containing information about the plugin. The `sign_plugin` function is invoked to create the signature file, and the `verify_plugin` function is used to validate the signature upon plugin loading.  The module produces a `plugin.sig` file as output. It relies on the Plugin Manager for overall plugin lifecycle management.",
  "/home/eliezer/devs/xcore/xcore/sandbox/tools/errorlanding.py:dd06c886db6c0456ecce2cdd6b19b5cb052bed35a014ba100a6cb47cd1c00607": "**Technical Summary of ErrorLanding Module**\n\n**Purpose:** This module provides a centralized mechanism for handling and reporting exceptions within the xCore system. It facilitates logging errors with detailed timing information and generates standardized exception responses.\n\n**Key Components:**\n*   `ExceptionResponse`: A Pydantic model representing an error response, containing type, message, and optional extension field.\n*   `Error`: The primary class, offering static methods for handling different types of exceptions (info, warning, error).\n*   `exception_handler`: A decorator that wraps functions to handle exceptions gracefully, logging details and returning a standardized error response.\n\n**Dependencies:** This module utilizes the `logging` library for structured logging and the `time` module for timing execution. It also leverages Pydantic for data validation and model definition.\n\n**Interactions:** The `Error` class is called by other modules to handle exceptions during function executions. Specifically, the `exception_handler` decorator intercepts exceptions raised within decorated functions, logs them with timestamps, and returns a consistent `ExceptionResponse`.  It calls static methods like `__info`, `__warning`, and `__error` based on the exception type. The module primarily consumes logging data and produces standardized error responses for consumption by other parts of the system.",
  "/home/eliezer/devs/xcore/xcore/integration/core/integration.py:b10e6f147f8b253325ca3e26b5824623d42435d19315b8807f498b1c37bc7d14": "## Technical Summary of `integration.py`\n\n**Purpose:** This file serves as the central orchestrator for the XCore service integration framework. It initializes and manages all registered services, providing a unified interface for accessing them within the broader XCore system. Specifically, it handles loading configuration, instantiating services (cache, database, scheduler), and exposing them through a centralized registry.\n\n**Key Components:**\n\n*   `Integration`: The primary class responsible for managing the entire integration framework lifecycle. It initializes services, provides access to them via a registry, and handles shutdown procedures.\n*   `IntegrationConfig`:  Holds configuration data retrieved from YAML files, defining settings for logging, database connections, cache parameters, and service extensions.\n*   `ServiceRegistry`: A central repository for storing and retrieving instantiated services.\n*   `ExtensionLoader`: Loads and initializes services defined in the integration configuration's extension section.\n*   `CacheService`, `DatabaseManager`, `SchedulerService`: Concrete implementations of core infrastructure services (cache, database management, and scheduling) that are registered within the registry.\n\n**Dependencies:**\n\n*   `asyncio`: For asynchronous operations related to service initialization and shutdown.\n*   `logging`:  For logging framework functionality.\n*   `pathlib`: For path manipulation.\n*   `IntegrationConfig`: Configuration data is loaded from YAML files.\n*   Internal modules: `ServiceRegistry`, `ExtensionLoader`, `CacheService`, `DatabaseManager`, `SchedulerService`.\n\n**Interactions:**\n\nThe `Integration` class is instantiated once at application startup (using the `setup()` function). It then asynchronously initializes all registered services and makes them accessible through its `get()` method.  It's called by other parts of the XCore system to access database operations, caching mechanisms, or scheduled tasks. The `init()` method performs asynchronous initialization, while `init_sync()` provides a synchronous wrapper for contexts that don\u2019t support async/await. The `shutdown()` method gracefully shuts down all services and resets the framework's state.  The `status()` method returns an overview of the integration framework's current state.\n",
  "/home/eliezer/devs/xcore/xcore/integration/core/integration.py:b4f22971d4e1cbdcb3f057895906c87ef73ee2a3152c4de12472dcbc1082c401": "**Technical Summary \u2013 Integration Module**\n\nThis module provides a centralized entry point for accessing various services within the XCore system. Its primary purpose is to instantiate and manage the core integration object, facilitating service retrieval across the codebase.\n\n**Key Components:**\n*   `get_service()`: A function that quickly retrieves a specific service instance based on its name.\n*   `_integration`: The central integration object responsible for managing all services.\n\n**Dependencies:**\nThis module relies internally on `_integration`, which in turn utilizes the `Integration` class and potentially other internal modules within the XCore framework. It does not directly depend on external libraries.\n\n**Interactions:**\nThe `get_service()` function is designed to be called from anywhere in the codebase, providing a consistent interface for accessing services. The module itself is instantiated by the setup process, and it\u2019s primary role is to expose service access via the `get` method of the `_integration` object. It does not directly call or produce data; instead, it orchestrates interactions with other modules within XCore.",
  "/home/eliezer/devs/xcore/xcore/integration/core/registry.py:c35f79ecf4b5414930630c51e0fe729f8cbc5df14bb01bcdb165c9fecb72afa8": "## Technical Summary of `xcore/integration/core/registry.py`\n\n**Purpose:** This file implements a centralized service registry within the xCore system, facilitating dependency injection and lazy loading of services. It provides a single point for registering, resolving, and managing service instances across the application. The core functionality supports various scopes (singleton, transient, scoped) to control instance lifecycle management.\n\n**Key Components:**\n\n*   `ServiceRegistry`: The primary class responsible for managing all registered services. It handles registration, resolution, and introspection operations.\n*   `ServiceDescriptor`: Represents a service definition, containing its name, factory function for instantiation, scope, and associated tags.\n*   `ServiceScope`: An enum defining the different scopes available for service instances (singleton, transient, scoped).\n\n**Dependencies:**\n\n*   `inspect`: Used for introspection to dynamically determine parameter types and arguments for service factories.\n*   `logging`: Utilized for logging registry events and debugging purposes.\n*   `enum`: Provides the `Enum` class for defining the `ServiceScope` enum.\n*   `typing`:  Provides type hints for improved code clarity and static analysis.\n\n**Interactions:**\n\nThe `ServiceRegistry` is accessed globally via the `get_registry()` function, establishing a singleton instance. Developers register services using `register()`, `register_class()`, or `register_instance()`. Resolution occurs through the `resolve()` method, accepting either a service name or type as input. The registry utilizes aliases to map service names to their fully qualified class names for flexible resolution.  The registry is called by other modules within xCore to obtain instances of services based on their defined scope and configuration. It primarily consumes service factories and produces resolved service instances.",
  "/home/eliezer/devs/xcore/xcore/integration/core/events.py:e283507a690235c75cc7914a21e85499ed4876bfb0a99a76c1463ef9dc5b5dc8": "## Technical Summary of `events.py`\n\n**1. Purpose:**\n\nThis file implements an asynchronous event bus system, dubbed \u201cIntegrations.Events,\u201d designed for loosely coupled communication within the XCore project. It provides a mechanism to trigger actions based on events, mirroring an EventEmitter pattern with prioritization and filtering capabilities. The primary goal is to decouple components and enable reactive behavior throughout the system.\n\n**2. Key Components:**\n\n*   `Event`: Represents a single event instance, containing its name, associated data, source, and a flag to control propagation of handlers.\n*   `HandlerEntry`:  Represents a handler function registered for an event, including its priority, whether it's a one-shot handler, and its name (used for logging).\n*   `EventBus`: The core class managing event subscriptions and emissions. It maintains a dictionary (`_handlers`) mapping event names to lists of `HandlerEntry` objects.\n\n**3. Dependencies:**\n\n*   `asyncio`: Provides asynchronous programming support for handling events concurrently.\n*   `logging`: Used for logging debug information related to handler registrations and errors.\n*   `dataclasses`: Utilized for defining the `Event` and `HandlerEntry` classes, providing a concise way to structure data.\n\n**4. Interactions:**\n\nThe `EventBus` is instantiated as a singleton (`get_event_bus()`). Developers use the `on()` and `once()` decorators to register handler functions for specific events. The `emit()` method triggers these handlers asynchronously (or synchronously if `gather=False`), passing event data.  Handlers can be unsubscribed using the `unsubscribe` method. The bus internally sorts handlers by priority before emitting events, ensuring that higher-priority handlers are executed first. Error handling is implemented within the handler execution process to prevent failures from disrupting other handlers.",
  "/home/eliezer/devs/xcore/xcore/integration/config/loader.py:f1f8e4bcd7f24421f701094be6075023ba6507ea670da929fd8f06cb76d83b25": "## Technical Summary: Configuration Loader for XCore Integrations\n\n**Purpose:** This file, `loader.py`, provides a mechanism to load and parse configuration data for various integrations within the XCore system. Specifically, it handles loading the `.env` file, substituting environment variables into YAML files (like `integration.yaml`), applying overrides based on environment variables, and ultimately constructing an `IntegrationConfig` dataclass.\n\n**Key Components:**\n\n*   `ConfigLoader`: The main class responsible for orchestrating the entire configuration loading process.\n*   `_load_dotenv(env_file)`: Loads environment variables from a `.env` file using either the built-in parser or the `python-dotenv` library.\n*   `_resolve_env(value)`:  A recursive function that replaces `${VAR}` placeholders in YAML strings with their corresponding values from the environment, handling potential missing environment variables gracefully.\n*   `_apply_env_overrides(raw)`: Applies configuration overrides based on patterns like `INTEGRATION__SECTION__KEY=value`.\n*   `_parse(raw)`: Parses the processed YAML data into an `IntegrationConfig` dataclass, containing sections for app settings, extensions, databases, caching, scheduling, and logging.\n\n**Dependencies:**\n\n*   `yaml`:  For parsing YAML files (requires installation via `pip install pyyaml`).\n*   `python-dotenv` (optional): For loading `.env` files if the built-in parser is unavailable.\n*   `os`: Provides access to environment variables.\n*   `re`: Regular expression library for placeholder substitution.\n*   `pathlib`:  For working with file paths.\n\n**Interactions:**\n\nThe `ConfigLoader` primarily *calls into* functions like `_load_dotenv`, `_resolve_env`, and `_apply_env_overrides`. It also *consumes* data from YAML files (specifically, `integration.yaml`). The resulting `IntegrationConfig` is then used by other parts of the XCore system to configure its integrations.  The loader's primary role is to provide a standardized configuration object for downstream components.",
  "/home/eliezer/devs/xcore/xcore/integration/config/loader.py:d845fad6e04b11df0adc303fcb90f7a898869d738de955ff778126d0179f7ab7": "## Technical Summary - Configuration Loader\n\n**Purpose:** This file provides a centralized mechanism for loading and managing application configuration settings, supporting multiple configurations (cache, scheduler, logging).\n\n**Key Components:**\n*   `ConfigLoader`: The primary class responsible for parsing configuration data from dictionaries.\n*   `CacheConfig`, `SchedulerConfig`, `LoggingConfig`: Classes representing the parsed configuration structures for cache management, scheduling jobs, and configuring logging.\n\n**Dependencies:**\n*   `cfg`: A presumed configuration library providing access to settings via a dictionary (`d`).\n*   `typing.Dict`, `typing.Optional`, `pathlib.Path`: Standard Python modules used for type hinting and path manipulation.\n\n**Interactions:**\nThe `get_config` function serves as the entry point, returning a singleton instance of `IntegrationConfig`. This configuration is loaded from a specified file path or defaults to loading from a global state if no path is provided. The loader parses configuration dictionaries into specific config objects (CacheConfig, SchedulerConfig, LoggingConfig) based on keys and values within those dictionaries. It calls the `_parse_*` static methods for each configuration type.  The loaded configurations are then accessible through the singleton `_config` object throughout the application.",
  "/home/eliezer/devs/xcore/xcore/integration/config/schemas.py:b31a5a5fe7001e6c001e4ae0f999527367306d4a15a6861db198561963e087cd": "## Technical Summary\n\nThis file defines configuration structures for various system components, facilitating flexible application setup. The core purpose is to manage and centralize settings across the xCore platform.\n\n**Key Components:**\n*   `AppConfig`: Defines basic application parameters like name, environment, and debug mode.\n*   `ExtensionConfig`: Configures individual service extensions with details such as enabled status, background modes, and resolved environment variables.\n*   `DatabaseConfig`: Specifies database connection settings including type, URL, and pool size.\n*   `CacheConfig`: Defines caching parameters like backend, TTL, and maximum size.\n*   `SchedulerJobConfig`: Represents a scheduled task configuration with details on function, trigger, and timing.\n*   `SchedulerConfig`: Configures the scheduler itself, specifying its enabled state and backend.\n*   `LoggingConfig`: Sets logging levels and formats.\n*   `IntegrationConfig`: Combines all configurations into a single object.\n\n**Dependencies:** This file utilizes dataclasses for structure and type hinting, relying on `typing` module for generic types.\n\n**Interactions:** The `IntegrationConfig` acts as the central point of configuration. It\u2019s consumed by other modules to retrieve settings (e.g., accessing environment variables via `self.config[\"host\"]`).  It's called upon during application initialization and potentially updated dynamically based on runtime conditions. Data is produced through structured configuration objects used throughout the system.",
  "/home/eliezer/devs/xcore/xcore/integration/services/snapshot.py:240cc59c4a44c2d5ee0fd9f79deeb7ae1f73c7222642ffef07b1a0f5318261df": "## Snapshot Service Technical Summary\n\n**Purpose:** This service generates a snapshot of files within a specified directory by calculating their SHA256 hashes. It\u2019s used to detect changes in file content, triggering updates or notifications.\n\n**Key Components:**\n*   `SnapshotService`: Orchestrates the snapshot creation and change detection process.\n*   `_should_ignore()`: Filters out ignored files based on hidden status, extensions, and filenames.\n*   `_hash_file()`: Computes the SHA256 hash of a file\u2019s content.\n\n**Dependencies:**\n*   `hashlib`: For secure hashing algorithms.\n*   `logging`: For structured logging.\n*   `pathlib`: Provides an object-oriented way to interact with files and directories.\n*   `PluginsConfig`: Configuration data for snapshot settings (ignored extensions, filenames).\n\n**Interactions:**\nThe `SnapshotService` is called by other modules within the system when a directory needs to be monitored for changes. It receives the current state of the directory as a dictionary of file hashes (`new`) and compares it against a previously stored snapshot (`old`). The `diff()` function calculates the differences, identifying added, removed, or modified files.  The service logs errors during hashing and produces a dictionary representing the snapshot data.",
  "/home/eliezer/devs/xcore/xcore/integration/services/scheduler.py:961bee27e9243cd4aeb0e5740b362ab1e221564fd3ace36a5a8f25fd5f160ea2": "## Technical Summary - Scheduler Service\n\n**Purpose:** The `scheduler` service manages and executes scheduled tasks within the xCore system. It leverages APScheduler as its backend, providing flexible scheduling options including cron expressions, intervals, and one-shot triggers.  The service is configurable via an external YAML file (`integration.yaml`).\n\n**Key Components:**\n\n*   **`SchedulerService` Class:** The core class responsible for managing the scheduler instance, job registration, and execution control.\n*   `_import_func(dotted_path)`: A helper function that dynamically imports functions from their specified dotted paths (e.g., `myapp.tasks:my_function`).\n*   **APScheduler Backend:** Utilizes either Redis or a SQLite database for persistent job storage, configurable via the integration configuration.\n*   **SchedulerJobConfig:**  A data structure representing a single scheduled task definition loaded from the YAML file.\n\n**Dependencies:**\n\n*   `apscheduler`: The primary scheduling library.\n*   `importlib`: For dynamic module importing.\n*   `logging`: For logging events and errors.\n*   `integration.yaml`: Configuration file defining scheduler settings, jobs, and triggers.\n\n**Interactions:**\n\nThe `SchedulerService` is initialized by the system upon startup via the `init()` method. It reads job definitions from `integration.yaml`, dynamically imports functions associated with those jobs using `_import_func`, and registers them with the APScheduler backend.  Jobs are added to the scheduler using the `add_job()` method, which accepts a function, trigger type (cron, interval), and an ID. The service provides methods for pausing, resuming, listing active jobs, and gracefully shutting down the scheduler. Data is primarily consumed from the configuration file and produced as job executions.  The scheduler interacts with external systems via the functions it executes.",
  "/home/eliezer/devs/xcore/xcore/integration/services/database.py:e51f3c4c13f1ede27db0802face090fb54ae01b9898cc8b8699ef7886a4d1dc1": "## Technical Summary - Database Service\n\n**Purpose:** This file provides a centralized service for managing database connections across various types (SQLite, PostgreSQL, MySQL, Redis, MongoDB) based on configuration settings. It facilitates interaction with these databases through a consistent API and manages connection pooling and lifecycle.\n\n**Key Components:**\n\n*   `SQLAdapter`: Handles traditional SQL databases (SQLite, PostgreSQL, MySQL) using SQLAlchemy.  It manages engine creation, session management, and database operations.\n*   `AsyncSQLAdapter`: Supports asynchronous SQL databases like PostgreSQL and MySQL with `asyncpg` or `aiomysql`. It utilizes `asyncio` for non-blocking I/O.\n*   `RedisAdapter`: Provides a connection to Redis for caching and messaging using the `redis-py` library.\n*   `MongoAdapter`:  Connects to MongoDB databases via the `pymongo` driver.\n*   `DatabaseManager`: Orchestrates the initialization, access, and closing of all database adapters based on configuration data. It provides a central point for managing connections and sessions.\n\n**Dependencies:**\n\n*   `sqlalchemy`: For SQL database interaction (both synchronous and asynchronous).\n*   `redis-py`:  For Redis connection management.\n*   `pymongo`: For MongoDB connectivity.\n*   `asyncpg` / `aiomysql`: Required for the asynchronous SQL adapters.\n*   `logging`: For logging events and errors.\n\n**Interactions:**\n\nThe `DatabaseManager` is the primary entry point. It initializes database connections based on configuration data (`IntegrationConfig`).  It provides a `session()` context manager to manage database transactions, allowing developers to interact with databases using SQLAlchemy sessions. The adapters themselves handle specific database operations (queries, inserts, updates) and provide methods for managing their respective connection pools. The `get()` method allows access to the initialized adapter by name.",
  "/home/eliezer/devs/xcore/xcore/integration/services/cache.py:510cf966a87c5b89ddb3fa871288881a6fd9071f542e08515f5a7732f97c4632": "## Technical Summary: Cache Service\n\n**1. Purpose:**\n\nThe `cache` module provides a unified API for managing cached data, supporting multiple backends including in-memory (MemoryBackend), and Redis (RedisBackend). Its primary goal is to decouple application logic from caching mechanisms, improving performance and scalability by reducing redundant database queries or computationally expensive operations. The service offers a consistent interface regardless of the underlying cache implementation.\n\n**2. Key Components:**\n\n*   `MemoryBackend`: A simple in-memory cache using a dictionary for storing key-value pairs with Time To Live (TTL) expiration.\n*   `RedisBackend`:  A backend that utilizes the Redis database for caching, providing persistence and potentially higher throughput. It uses JSON serialization/deserialization for data storage.\n*   `CacheService`: The core service class that orchestrates interactions with the chosen backend. It handles key retrieval, setting values with TTLs, deletion, and provides a unified API.\n*   `cached` decorator: A decorator to automatically cache function results based on specified keys and TTLs.\n\n**3. Dependencies:**\n\n*   `redis`:  A Python client library for interacting with Redis (required only when `RedisBackend` is used).\n*   `json`: For serializing/deserializing data stored in the Redis backend.\n*   `logging`: For logging events and errors.\n*   `functools`: Used by the `cached` decorator to manage function wrapping.\n\n**4. Interactions:**\n\nThe `CacheService` is called by other modules within the system to perform caching operations. It interacts with the selected backend (MemoryBackend or RedisBackend) based on the configuration. The `cached` decorator dynamically modifies functions to intercept calls, retrieve values from the cache if available, and store results in the cache upon execution. Data flows primarily into the cache via `set()` and out via `get()`, with deletion handled separately.  The service manages its own state (backend instance) internally.",
  "/home/eliezer/devs/xcore/xcore/integration/plugins/manager.py:c55133950c6fda21b25f6ab2f4f55e5ced5f0eab3742173565ec263b724ab0ed": "## Technical Summary of `manager.py`\n\n**Purpose:** This file, `manager.py`, serves as the central orchestrator for the xCore integration framework. It initializes and manages all integrated services \u2013 database connections, caching mechanisms, scheduling tasks, and external extensions \u2013 providing a unified interface for accessing them within the xCore system.  It's designed to be a single point of control for managing service dependencies and configurations.\n\n**Key Components:**\n\n*   `Integration`: The core class responsible for loading configuration, instantiating services, and maintaining a global registry.\n*   `ExtensionLoader`: Handles the dynamic loading and initialization of external service extensions defined in an `integration.yaml` file.\n*   `ServiceRegistry`: A central repository that stores instances of all registered services, allowing easy access via their names.\n*   `DatabaseManager`, `CacheService`, `SchedulerService`: Concrete implementations for managing database connections, caching operations, and scheduled tasks respectively.\n\n**Dependencies:**\n\n*   `asyncio`: For asynchronous operation and event loop management.\n*   `logging`:  For logging framework functionality.\n*   `pathlib`: For path manipulation.\n*   `IntegrationConfig`: Configuration data loaded from `integration.yaml`.\n*   `ServiceRegistry`: Used internally for service registration.\n\n**Interactions:**\n\nThe `Integration` class is instantiated once and globally accessible via the `setup()` function.  It's primarily used to:\n\n*   Initialize services asynchronously using `init()`, which loads configuration, creates instances of database, cache, and scheduler services, and initializes extension loaders.\n*   Provide access to these services through methods like `get()`, `db`, `cache`, and `scheduler`.\n*   Handle service shutdown gracefully via the `shutdown()` method.  The `setup` function is a singleton that ensures only one instance of the integration framework exists. It's designed for initialization during application startup.",
  "/home/eliezer/devs/xcore/xcore/integration/plugins/manager.py:9d94a0b1ba12afa40d597144c99eda0b91ebbcbd63d05187227922ead9687b48": "**Technical Summary \u2013 Manager Module**\n\nThis module provides a centralized interface for accessing and managing various services within the XCore system. Its primary purpose is to simplify service retrieval across different parts of the codebase.\n\n**Key Components:**\n*   `get_service()`: A function that retrieves a specific service instance based on its name, utilizing the `Integration` class.\n*   `Integration`:  A core class responsible for managing and accessing available services.\n\n**Dependencies:**\n*   `Integration`: This module relies heavily on the `Integration` class to handle service interactions. It implicitly uses internal modules related to service discovery and configuration.\n\n**Interactions:**\n*   The `get_service()` function is designed to be called from anywhere in the codebase, providing a consistent way to access services.\n*   It calls the `Integration`\u2019s `get()` method to retrieve the requested service. The `Integration` class likely interacts with other modules for tasks like database connections and message queuing. It initializes an instance of `Integration` using configuration data.",
  "/home/eliezer/devs/xcore/xcore/integration/plugins/base.py:b4ed06db9d7691d01e86ce2ef857cf8058cfece7008dc8087bb641976c33b666": "## Technical Summary \u2013 BaseService Module\n\n**Purpose:** This module defines a foundational service contract for all extensions within the XCore system, facilitating communication and configuration management between services and the core application. It provides a standardized interface for service initialization, setup, and monitoring.\n\n**Key Components:**\n*   `BaseService`: The central class defining the service contract with methods for `setup`, `teardown`, registry access, and readiness status tracking.\n*   `ServiceNotReadyError`: An exception raised when a service hasn't completed its initialization.\n\n**Dependencies:** This module relies on the `logging` library for logging functionality and utilizes type hints (`typing`) for improved code clarity and maintainability. It does not directly import external libraries.\n\n**Interactions:**\n*   **Called By:** The `Integration` class (not shown) uses this module to instantiate and manage services.\n*   **Calls Into:**  The `BaseService` class provides methods that other services can call for tasks like accessing environment variables (`self.env`) or retrieving other registered services (`get_service`).\n*   **Data Produced/Consumed:** Services utilize the `self.env` dictionary to access resolved environment variables, and the `setup()` method is used to perform service-specific initialization. The `is_ready` property indicates a service's readiness state.",
  "/home/eliezer/devs/xcore/xcore/integration/plugins/extension_loader.py:8697de6bfb96f68c6d14220cb8d6264cd32acffc57da0a8f9e9a27ba3a483c3c": "## Technical Summary: Extension Loader\n\n**Purpose:** The `extension_loader.py` module facilitates the instantiation, configuration, and management of external services defined within a project\u2019s YAML-based extension system. It provides a central registry for these services, enabling their invocation via a standardized interface.\n\n**Key Components:**\n\n*   `_import_class(dotted: str) -> type`: Dynamically imports Python classes from specified module paths based on dotted notation (e.g., `module.path:ClassName`).\n*   `ServiceWorker`:  A core class responsible for managing the lifecycle of a single service instance, handling both asynchronous and synchronous execution modes, along with background job scheduling using APScheduler. It includes mechanisms for restarting failed instances and logging errors.\n\n**Dependencies:**\n\n*   `asyncio`: For asynchronous programming within the `ServiceWorker`.\n*   `importlib`: Used by `_import_class` to dynamically import Python modules and classes.\n*   `logging`:  For structured logging of events, errors, and status updates.\n*   `threading`: Enables concurrent execution of service instances in both synchronous and asynchronous modes.\n*   `apscheduler`: A library for scheduling tasks (background jobs) within the `ServiceWorker`.\n\n**Interactions:**\n\nThe module is primarily used by the integration layer to retrieve services. Specifically, the `get_service()` function (from a separate `integrations` module \u2013 not documented here) uses this loader to instantiate and manage external service instances based on their YAML configuration. The `ServiceWorker` class itself manages the execution of these services, handling both synchronous and asynchronous tasks, as well as scheduled background jobs.  It interacts with the system through its `run_sync()` and `run_async()` methods (which are expected to be implemented by the individual service extensions), and utilizes APScheduler for managing recurring tasks.",
  "/home/eliezer/devs/xcore/xcore/integration/plugins/extension_loader.py:d96bdcdce8fd4da422de32df96e6aba307a99bc3fba87ebb66eb61cf3472e805": "## Technical Summary - Extension Loader Plugin\n\n**Purpose:** The `extension_loader.py` file manages the initialization and operation of services defined in an integration configuration (YAML). It provides a central point for instantiating, monitoring, and shutting down these services within the system.\n\n**Key Components:**\n\n*   `ExtensionLoader`: The core class responsible for orchestrating service loading, managing service instances, and providing status information.\n*   `ServiceWorker`: A worker process that handles background tasks associated with specific services (e.g., continuous polling or long-running operations).\n*   `BaseService`: An abstract base class defining the common interface for all registered services.\n\n**Dependencies:**\n\n*   `IntegrationConfig`:  Contains configuration data for each service, including enabled status and settings.\n*   `Any`: Used as a type hint to represent any object (likely a registry).\n*   `_import_class`: A utility function (not defined here) responsible for dynamically importing the class definition of a service based on its name in the configuration.\n*   `logger`:  The standard Python logging module for recording events and errors.\n\n**Interactions:**\n\nThis file is called during system startup via `init_all()`. It loads services from the `IntegrationConfig`, instantiates them using dynamic class importing, and registers them with a central service registry (`self._registry`). The `get()` method provides access to individual services by name.  The `status()` function returns a list of dictionaries describing each service's state (ready status, worker details). Finally, the `shutdown_all()` method gracefully shuts down all running services and their associated workers. It relies on the `setup()` and `teardown()` methods within the `BaseService` class for proper resource cleanup.",
  "/home/eliezer/devs/xcore/xcore/integration/plugins/schemas.py:2d8f14eec1b09f96dd0ec0feb51d7271b13a7f4add76aba565db634668923848": "## Technical Summary \u2013 Service Worker State\n\n**Purpose:** This file defines a data structure and associated logic for managing the state of individual service workers within the XCore system. It tracks status, restarts, and error information to provide insights into worker health.\n\n**Key Components:**\n*   `ServiceStatus`: An enum representing different states of a service (Idle, Starting, Running, Crashed, Stopped).\n*   `ServiceWorkerState`: A dataclass holding the state information for a single service worker, including name, status, restart count, and error details. It utilizes threading events to manage worker lifecycle.\n\n**Dependencies:** Utilizes standard Python libraries like `logging`, `dataclasses`, `enum`, and `threading`.\n\n**Interactions:** This module is likely called by an integration layer responsible for monitoring service workers. It provides data to a scheduler component, potentially triggering restarts or alerts based on the worker\u2019s status. The `_stop` event allows external control over worker termination.  It consumes information from the logging system and produces state updates relevant to overall system health monitoring."
}